#### java-basic-auto-boxing-unpacking

Java 程序自动拆装箱

数据类型按照存储方式可以分为值类型和引用类型。两者仍然可以互相转换。

将值类型转换为引用类型的过程称为装箱，反之为拆箱。

不明确

Java 是否存在自动装箱拆箱功能√

 1、函数返回值为基础数据类型能否使用引用类型接收。√

 2、函数返回值为引用数据类型能否使用基数数据类型接收。√

 3、函数返回值为 Object 类型，能否使用基础数据类型返回。√

 4、引用数据类型进行操作符运算后的结果，能否使用基数数据类型接收。√

 5、引用数据类型的比较方法。

  使用 Object 的 equals 方法比较数据值是否相同。√

  使用 == 操作符比较数据内存地址是否相同。√

 6、引用数据类型与基础数据类型的比较方法。

  使用 == 操作符，或使用 Object 对象的 equals 方法。√

Integer

Integer 内部有一个缓冲池，在 -128~127 之间的数据通过系统自动拆装箱得到的是从缓存池中获得到的。

通过 new 操作符创建的 Integer 对象即使值在 -128~127 之间也不会使用缓存池中的对象。

数值不在 -128~127 之间的变量赋值，每次都会隐式使用 new 操作符创建新的 Integer 对象。

对 Integer 类型对象使用赋值操作符做了什么？

 对对象进行赋值运算符操作是将内存地址赋值给对象的。

 内存中的值是如何操作的？

 基础数据类型数组通过数组下标配合赋值运算符进行赋值。

JavaBean 是如何进行赋值的？

 通过调用对象的 setter 方法完成对 JavaBean 中内部属性的赋值。

 操作不会修改 JavaBean 对象本身内存地址的指向。

JavaBean 对象的创建

 通过 new 操作符可以创建新的 JavaBean 对象。

 通过赋值运算符可以将 JavaBean 对象进行引用方式传递。

 Java 中的引用类型变量，所指向的都是一块内存地址。重新对对象赋值意味着会丢失原有内存地址的指向。

 如果没有任何变量指向该地址，在下次进行 gc 操作时，该空间会被回收。

 也就是说如果对象不是通过自己的程序生成的而是获取的内存地址（对象的引用），则会一直存在不会被系统 gc 回收。

 也就是说无法通过改变对象的内存地址，来改变原对象中的数据。原对象会由其它变量的引用从而继续存在。

 如 Spring 容器中的对象，在系统退出之前是不会被回收的。

Java 中的操作符

 - 运算符

 - instanceof

 - ? :

 - & && | || == < > >> >>> << <<<
