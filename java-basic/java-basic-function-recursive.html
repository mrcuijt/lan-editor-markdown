<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>java-basic-function-recursive</title>
</head>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/LanEditor.css"/>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/highlight/styles/idea.css">

<link href="../plugin/SyntaxHighlighter/main.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shCore.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shThemeDefault.css" rel='stylesheet' type='text/css'>
<link href="../plugin/LanEditor/main.css" rel='stylesheet' type='text/css'>

<script src="../plugin/SyntaxHighlighter/shCore-convert.js" type='text/javascript'></script>
<script src="../plugin/SyntaxHighlighter/shBrushAll.js" type='text/javascript'></script>

<script type="text/javascript" src="../plugin/LanEditor/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="../plugin/autosize/autosize.bundle.js"></script>
<script type="text/javascript" src="../plugin/LanEditor/LanEditor.js"></script>

<script type="text/javascript">

    window.autosize = require("autosize");

    $(document).ready(function () {
        //初始化 @textelem:编辑区的id @showelem可以省略
        var lan = LanEditor.init({
            textelem: "editor",
            showelem: "show"
        });
        //如果初始化失败，则显示出错信息
        if(lan.status == false){
            alter(lan.message);
            return ;
        }else{
            // 默认保存LanEditor快速指南文件
            // 获取文件创建的时间
            var createTime = LanEditor.Time.GetTimestamp();
            // 文件名
            LanEditor.File.CurOpenFile.name = $(document).attr("title");
            // 创建时间
            LanEditor.File.CurOpenFile.time = createTime;
            // 保存文件
            LanEditor.File.SaveFile();
            // 渲染
            LanEditor.RenderHTML();
        }
    });
</script>
<body>
<div id="edit">
    <textarea id="editor" name="editor">
#### java-basic-function-recursive

#### 方法的递归调用（了解）

&amp;#160; &amp;#160;递归调用是我们迈向数据结构开发的第一步，但是如果你要真想要把递归操作掌握熟练，那么你需要大量的代码积累才可能写出递归，换个角度，如果说现在在标准的项目开发里面，你们是很难去写上递归操作的。

**所谓的递归调用指的就是 `一个方法自己调用自己` 的情况。**

 - **但是如果要想实现自己调用自己，一定需要 `一个结束的条件` 。**
 
 **并且 `每次调用的时候都需要修改这个结束条件。`**

之所以在开发中尽量减少调用，是因为如果处理不当，就可能出现内存的溢出。

##### 范例：实现一个 1~100 的累加操作

```java
public class TestDemo {

  public static void main(String[] args){
    int sum = 0;
    int current = 1;
    while(current <= 100){
      sum += current;
      current++;
    }
    System.out.println(sum);
  }
}
```

那么如果说此时要将以上的代码变为递归的操作呢？

递归操作是一定要发生在一个方法上的。

##### 范例：递归调用

```java
public class TestDemo {

  public static void main(String[] args){
    System.out.println(sum(100)); // 1 ~ 100 累加
    System.out.println(sum(200)); // 1 ~ 200 累加
  }

  public static int sum(int num){
    if(num == 1){  // 递归的结束调用
      return 1; // 最终的结果返回了一个 1
    }
    return num + sum(num - 1); // 递归调用
  }
}
```

下面使用方法调用的方式分析以上代码的操作步骤。

 - **1、主方法调用 sum(100) ，return 100 + sum(99);**
 
 - **2、递归调用 sum(99)，return 99 + sum(98);**
 
 - **3、递归调用 sum(98)，return 98 + sum(97);**
 
 **.....**
 
 - **4、倒数第 2 次递归调用 sum(2) ，return 2 + sum(1);**
 
 - **5、倒数第 1 次递归调用 sum(1) ，return 1; 不再递归，符合结束条件。**

**`递归调用从最低层的结果层层向上返回相加，直至到栈顶结束。`**

**1 + 2 + 3 + 4 + 5 ... 97 + 98 + 99 + 100 = 5050**

##### 总结

 - **1、可以将一些重复执行的代码定义在方法（Method）里面**
 
 **，方法在有些书上也被称为函数（Function）。**

 - **2、本次所讲解的方法是有局限性：定义主类，并且由主方法直接调用；**

 - **3、方法的返回值一旦定义了，就需要使用 return 返回相应数据；**

 - **4、方法重载（Overloading）指的是方法的名称相同，参数的类型及个数不同**
 
 **，同时尽量保证返回值类型相同。**

 - **5、递归调用需要明确的设置一个结束的条件，否则就会出现死循环**
 
 **，如果处理的数据一大，就有可能出现内存溢出。**

**所谓的递归调用指的就是 `一个方法自己调用自己` 的情况。**

 - **但是如果要想实现自己调用自己，一定需要 `一个结束的条件` 。**
 
 **并且 `每次调用的时候都需要修改这个结束条件。`**

之所以在开发中尽量减少调用，是因为如果处理不当，就可能出现内存的溢出。
	</textarea>
</div>

<div id="show"></div>
</body>
</html>