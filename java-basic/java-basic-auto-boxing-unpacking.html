<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>java-basic-auto-boxing-unpacking</title>
</head>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/LanEditor.css"/>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/highlight/styles/idea.css">

<link href="../plugin/SyntaxHighlighter/main.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shCore.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shThemeDefault.css" rel='stylesheet' type='text/css'>
<link href="../plugin/LanEditor/main.css" rel='stylesheet' type='text/css'>

<script src="../plugin/SyntaxHighlighter/shCore-convert.js" type='text/javascript'></script>
<script src="../plugin/SyntaxHighlighter/shBrushAll.js" type='text/javascript'></script>

<script type="text/javascript" src="../plugin/LanEditor/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="../plugin/autosize/autosize.bundle.js"></script>
<script type="text/javascript" src="../plugin/LanEditor/LanEditor.js"></script>

<script type="text/javascript">

    window.autosize = require("autosize");

    $(document).ready(function () {
        //初始化 @textelem:编辑区的id @showelem可以省略
        var lan = LanEditor.init({
            textelem: "editor",
            showelem: "show"
        });
        //如果初始化失败，则显示出错信息
        if(lan.status == false){
            alter(lan.message);
            return ;
        }else{
            // 默认保存LanEditor快速指南文件
            // 获取文件创建的时间
            var createTime = LanEditor.Time.GetTimestamp();
            // 文件名
            LanEditor.File.CurOpenFile.name = $(document).attr("title");
            // 创建时间
            LanEditor.File.CurOpenFile.time = createTime;
            // 保存文件
            LanEditor.File.SaveFile();
            // 渲染
            LanEditor.RenderHTML();
        }
    });
</script>
<body>
<div id="edit">
    <textarea id="editor" name="editor">
#### java-basic-auto-boxing-unpacking

#### Java 程序自动拆装箱

 - **数据类型按照存储方式可以分为 `值类型` 和 `引用类型`。两者仍然可以互相转换。**

 - **将值类型转换为引用类型的过程称为装箱，反之为拆箱。**

##### 不明确

**Java 是否存在自动装箱拆箱功能√**

 - 1、函数返回值为基础数据类型能否使用引用类型接收。√

 - 2、函数返回值为引用数据类型能否使用基数数据类型接收。√

 - 3、函数返回值为 Object 类型，能否使用基础数据类型返回。√

 - 4、引用数据类型进行操作符运算后的结果，能否使用基数数据类型接收。√

 - 5、引用数据类型的比较方法。

 使用 Object 的 equals 方法比较数据值是否相同。√

 使用 == 操作符比较数据内存地址是否相同。√

 - 6、引用数据类型与基础数据类型的比较方法。

 使用 == 操作符，或使用 Object 对象的 equals 方法。√

##### Integer

 - **Integer 内部有一个缓冲池，在 `-128~127` 之间的数据通过系统自动拆装箱得到的，是从缓存池中获得到的。**

 - **通过 `new` 操作符创建的 Integer 对象即使值在 `-128~127` 之间也不会使用缓存池中的对象。**

 - **数值不在 `-128~127` 之间的变量赋值，每次都会隐式使用 `new` 操作符创建新的 Integer 对象。**

##### 对 Integer 类型对象使用赋值操作符做了什么？

 对对象进行赋值运算符操作是将内存地址赋值给对象的。

##### 内存中的值是如何操作的？

 基础数据类型数组通过数组下标配合赋值运算符进行赋值。

##### JavaBean 是如何进行赋值的？

 通过调用对象的 setter 方法完成对 JavaBean 中内部属性的赋值。

 操作不会修改 JavaBean 对象本身内存地址的指向。

##### JavaBean 对象的创建

 通过 new 操作符可以创建新的 JavaBean 对象。

 通过赋值运算符可以将 JavaBean 对象进行引用方式传递。

 - **Java 中的引用类型变量，所指向的都是一块内存地址。重新对对象赋值意味着会丢失原有内存地址的指向。**

 - **如果没有任何变量指向该地址，在下次进行 gc 操作时，该空间会被回收。**

 - **也就是说如果对象不是通过自己的程序生成的而是获取的内存地址（对象的引用），则会一直存在不会被系统 gc 回收。**

 - **也就是说无法通过改变对象的内存地址，来改变原对象中的数据。原对象会由其它变量的引用从而继续存在。**

 如 Spring 容器中的对象，在系统退出之前是不会被回收的。

##### Java 中的操作符

 - 运算符

 - instanceof

 - ? :

 - & && | || == < > >> >>> << <<<

	</textarea>
</div>

<div id="show"></div>
</body>
</html>