<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>java-basic-comparator-sort</title>
</head>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/LanEditor.css"/>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/highlight/styles/idea.css">

<link href="../plugin/SyntaxHighlighter/main.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shCore.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shThemeDefault.css" rel='stylesheet' type='text/css'>
<link href="../plugin/LanEditor/main.css" rel='stylesheet' type='text/css'>

<script src="../plugin/SyntaxHighlighter/shCore-convert.js" type='text/javascript'></script>
<script src="../plugin/SyntaxHighlighter/shBrushAll.js" type='text/javascript'></script>

<script type="text/javascript" src="../plugin/LanEditor/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="../plugin/autosize/autosize.bundle.js"></script>
<script type="text/javascript" src="../plugin/LanEditor/LanEditor.js"></script>

<script type="text/javascript">

    window.autosize = require("autosize");

    $(document).ready(function () {
        //初始化 @textelem:编辑区的id @showelem可以省略
        var lan = LanEditor.init({
            textelem: "editor",
            showelem: "show"
        });
        //如果初始化失败，则显示出错信息
        if(lan.status == false){
            alter(lan.message);
            return ;
        }else{
            // 默认保存LanEditor快速指南文件
            // 获取文件创建的时间
            var createTime = LanEditor.Time.GetTimestamp();
            // 文件名
            LanEditor.File.CurOpenFile.name = $(document).attr("title");
            // 创建时间
            LanEditor.File.CurOpenFile.time = createTime;
            // 保存文件
            LanEditor.File.SaveFile();
            // 渲染
            LanEditor.RenderHTML();
        }
    });
</script>
<body>
<div id="edit">
    <textarea id="editor" name="editor">
#### java-basic-comparator-sort

Import

```java
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Collections;

import java.io.File;
```

集合分组代码抽象实现

```java
public static <T> List<List<T>> divider(Collection<T> list, 
    Comparator<? super T> c){

  // group list
  List<List<T>> result = new ArrayList<List<T>>();

  if(list == null) return result;

  for(T t : list){

    // create new group
    boolean newGroup = true;

    for(int i = 0; i < result.size(); i++){
      // compare group
      if(c.compare(t, result.get(i).get(0)) == 0){
        // same group
        newGroup = false;
        // add to same group
        result.get(i).add(t);
        // exit group loop
        break;
      }
    }

    // create new group
    if(newGroup){
      List<T> innerList = new ArrayList<T>();
      // result add new group
      result.add(innerList);
      // new group add group item
      innerList.add(t);
    }

  }
  // return group list
  return result;
}
```

使用

```java
List<FileModel> fileModels = FileUtil.generateFileModels(files);
// Group By FileType
List<List<FileModel>> groupList = divider(fileModels, new Comparator<FileModel>(){
  @Override
  public int compare(FileModel fm1, FileModel fm2){
    return fm1.getFileType().compareTo(fm2.getFileType());
  }
});
```

分组集合排序

```java
fileModels = new ArrayList<FileModel>();
for(List<FileModel> group : groupList){
  // Group List Item Sort
  Collections.sort(group, new Comparator<FileModel>(){
    @Override
    public int compare(FileModel fm1, FileModel fm2){
      if(fm1.getFileName().length() == fm2.getFileName().length()){
        return fm1.getFileName().compareTo(fm2.getFileName());
      } else {
        return fm1.getFileName().length() - fm2.getFileName().length();
      }
    }
  });
  fileModels.addAll(group);
}
```

集合排序

```java
List<File> files = Files.dirs(input);
Collections.sort(files, new Comparator<File>(){
  @Override
  public int compare(File f1, File f2){
    if(f1.getName().length() == f2.getName().length()){
      return f1.getName().compareTo(f2.getName());
    } else {
      return f1.getName().length() - f2.getName().length();
    }
  }
});
```

参考链接：

 - <a href="https://blog.csdn.net/u012250875/article/details/55126531" target="_blank">Java Comparator 的用法</a>

#### Comparable 和 Comparator 的区别

##### 前言

初次碰到这个问题是之前有一次电话面试，问了一个小时的问题，其中有一个问题就问到 Comparable 和 Comparator 的区别，当时没答出来。之后是公司入职时候做的一套 Java 编程题，里面用 JUnit 跑用例的时候也用到了 Comparator 接口，再加上 JDK 的大量的类包括常见的 String、Byte、Char、Date 等都实现了 Comparable 接口，因此要学习一下这两个类的区别以及用法。

##### Comparable

Comparable 可以认为是一个内比较器，实现了 Comparable 接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了 Comparable 接口的类如何比较，则依赖 compareTo 方法的实现，compareTo 方法也被称为自然比较方法。如果开发者 add 进入一个 Collection 的对象想要 Collections 的 sort 方法帮你自动进行排序的话，那么这个对象必须实现 Comparable 接口。compareTo 方法的返回值是 int，有三种情况：

 - 1、比较者大于被比较者（也就是 compareTo 方法里面的对象），那么返回正整数

 - 2、比较者等于被比较者，那么返回 0

 - 3、比较者小于被比较者，那么返回负整数

写个很简单的例子：

```java
public class Domain implements Comparable<Domain> {
    private String str;

    public Domain(String str){
        this.str = str;
    }

    public int compareTo(Domain domain){
        if (this.str.compareTo(domain.str) > 0)
            return 1;
        else if (this.str.compareTo(domain.str) == 0)
            return 0;
        else 
            return -1;
    }
    
    public String getStr(){
        return str;
    }
}
```

```java
public static void main(String[] args){
    Domain d1 = new Domain("c");
    Domain d2 = new Domain("c");
    Domain d3 = new Domain("b");
    Domain d4 = new Domain("d");
    System.out.println(d1.compareTo(d2));
    System.out.println(d1.compareTo(d3));
    System.out.println(d1.compareTo(d4));
}
```

运行结果为：

```python
0
1
-1
```

注意一下，前面说实现 Comparable 接口的类是可以支持和自己比较的，但是其实代码里面 Comparable 的泛型未必就一定要是 Domain，将泛型指定为 String 或者指定为其他任何任何类型都可以----只要开发者指定了具体的比较算法就行。

##### Comparator

Comparator 可以认为是是一个外比较器，个人认为有两种情况可以使用实现 Comparator 接口的方式：

 - 1、一个对象不支持自己和自己比较（没有实现 Comparable 接口），但是又想对两个对象进行比较

 - 2、一个对象实现了 Comparable 接口，但是开发者认为 compareTo 方法中的比较方式并不是自己想要的那种比较方式

Comparator 接口里面有一个 compare 方法，方法有两个参数 T o1 和 T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和 Comparable 接口一样是 int，有三种情况：

 - 1、o1 大于 o2，返回正整数

 - 2、o1 等于 o2，返回 0

 - 3、o1 小于 o3，返回负整数

写个很简单的例子，上面代码的 Domain 不变（假设这就是第2种场景，我对这个 compareTo 算法实现不满意，要自己写实现）：

```java
import java.util.Comparator;

public class DomainComparator implements Comparator<Domain> {
    public int compare(Domain domain1, Domain domain2){
        if (domain1.getStr().compareTo(domain2.getStr()) > 0)
            return 1;
        else if (domain1.getStr().compareTo(domain2.getStr()) == 0)
            return 0;
        else 
            return -1;
    }
}
```

```java
public static void main(String[] args){
    Domain d1 = new Domain("c");
    Domain d2 = new Domain("c");
    Domain d3 = new Domain("b");
    Domain d4 = new Domain("d");
    DomainComparator dc = new DomainComparator();
    System.out.println(dc.compare(d1, d2));
    System.out.println(dc.compare(d1, d3));
    System.out.println(dc.compare(d1, d4));
}
```

看一下运行结果：

```java
0
1
-1
```

当然因为泛型指定死了，所以实现 Comparator 接口的实现类只能是两个相同的对象（不能一个 Domain、一个 String）进行比较了，因此实现 Comparator 接口的实现类一般都会以"待比较的实体类+Comparator"来命名

##### 总结

总结一下，两种比较器 Comparable 和 Comparator，后者相比前者有如下优点：

 - 1、如果实现类没有实现 Comparable 接口，又想对两个类进行比较（或者实现类实现了 Comparable 接口，但是对 compareTo 方法内的比较算法不满意），那么可以实现 Comparator 接口，自定义一个比较器，写比较算法

 - 2、实现 Comparable 接口的方式比实现 Comparator 接口的耦合性要强一些，如果要修改比较算法，要修改 Comparable 接口的实现类，而实现 Comparator 的类是在外部进行比较的，不需要对实现类有任何修改。从这个角度说，其实有些不太好，尤其在我们将实现类的 .class 文件打成一个 .jar 文件提供给开发者使用的时候。实际上实现 Comparator 接口的方式后面会写到就是一种典型的策略模式。

当然，这不是鼓励用 Comparator，意思是开发者还是要在具体场景下选择最合适的那种比较器而已。

##### 自然排序

自然排序使用要排序元素的 CompareTo(Object obj) 方法来比较元素之间大小关系，然后将元素按照升序排列。Java 提供了一个 Comparable 接口，该接口里定义了一个 compareTo(Object obj) 方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。 obj1.compareTo(obj2) 方法如果返回 0，则说明被比较的两个对象相等，如果返回一个正数，则表明 obj1 大于 obj2，如果是负数，则表明 obj1 小于 obj2。 如果我们将两个对象的 equals 方法总是返回 true，则这两个对象的 compareTo 方法返回应该返回 0。

实现类基于 compareTo() 方法的排序被称为自然排序。而 compareTo() 方法的排序被称为它的自然排序。具体的排序原则可由实现类根据需要而定。**`用户在重写 compareTo() 方法以定制比较逻辑时，需要确保其余等价性判断方法 equals() 保持一致`**，即 e1.equals((Object)e2) 和 e1.compareTo((Object)e2)==0 具有相同的值，这样的话我们就称自然顺序就和 equals 一致。

##### 定制排序

自然排序是根据集合元素的大小，以升序排列。

如果要定制排序，应该使用 java.util.Comparator 接口，实现 int compare(T o1, T o2) 方法。

java.lang.Comparable 接口定义的 compareTo() 方法用于提供对其实现类的对象进行整体排序所需要的比较逻辑。

参考链接：

 - <a href="https://www.cnblogs.com/xrq730/p/4850140.html" target="_blank">Comparable 和 Comparator 的区别</a>

 - <a href="https://blog.csdn.net/qq_23195583/article/details/44174181" target="_blank">cannot be cast to java.lang.Comparable 解决办法</a>

 - <a href="https://blog.csdn.net/Websphere_zxf/java/article/details/86418553" target="_blank">Java中的自然排序和比较器排序</a>

 - <a href="https://blog.csdn.net/lichaohn/article/details/5389276" target="_blank">Java中的排序比较方式：自然排序和比较器排序</a>
	</textarea>
</div>

<div id="show"></div>
</body>
</html>