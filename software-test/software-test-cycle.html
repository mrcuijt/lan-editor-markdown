<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>software-test-cycle</title>
</head>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/LanEditor.css"/>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/highlight/styles/idea.css">

<link href="../plugin/SyntaxHighlighter/main.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shCore.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shThemeDefault.css" rel='stylesheet' type='text/css'>
<link href="../plugin/LanEditor/main.css" rel='stylesheet' type='text/css'>

<script src="../plugin/SyntaxHighlighter/shCore-convert.js" type='text/javascript'></script>
<script src="../plugin/SyntaxHighlighter/shBrushAll.js" type='text/javascript'></script>

<script type="text/javascript" src="../plugin/LanEditor/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="../plugin/autosize/autosize.bundle.js"></script>
<script type="text/javascript" src="../plugin/LanEditor/LanEditor.js"></script>

<script type="text/javascript">

    window.autosize = require("autosize");

    $(document).ready(function () {
        //初始化 @textelem:编辑区的id @showelem可以省略
        var lan = LanEditor.init({
            textelem: "editor",
            showelem: "show"
        });
        //如果初始化失败，则显示出错信息
        if(lan.status == false){
            alter(lan.message);
            return ;
        }else{
            // 默认保存LanEditor快速指南文件
            // 获取文件创建的时间
            var createTime = LanEditor.Time.GetTimestamp();
            // 文件名
            LanEditor.File.CurOpenFile.name = $(document).attr("title");
            // 创建时间
            LanEditor.File.CurOpenFile.time = createTime;
            // 保存文件
            LanEditor.File.SaveFile();
            // 渲染
            LanEditor.RenderHTML();
        }
    });
</script>
<body>
<div id="edit">
    <textarea id="editor" name="editor">
#### software-test-cycle

#### 软件生命周期

 - 主题

  - 软件生命周期

  - 软件开发模型

  - 软件测试流程

  - 软件测试分类

#### 软件生命周期

 - ~ 是指软件从诞生到淘汰的全部过程。

 - 软件生命周期中的主要阶段

  - 计划阶段（项目立项阶段）

     - 项目产品计划

     - 可行性分析（产品研发）公司实力、人员、资金、设备

  - 需求阶段（需求分析师）

     - 需求分析、用户目标群体

     - 收集、过滤、分析、整理、需求转换

     - 用户需求 -> 产品需求 -> 技术需求

  - 设计阶段（软件架构、分析师）

     - 将需求转变成可行的技术方案

     - 软件的层次结构图、软件架构图

     - 数据库设计、ER 关系图、数据字典

     - 数据结构、算法

  - 开发和测试阶段（生产阶段）

     - 编码开发（程序生产者）

     - 测试（产品质量保整）

  - 部署和维护阶段

     - 软件实施、技术支持、售前、售后

     - 用户环境（部署安装）

     - 用户培训

     - 数据维护

  - 升级和淘汰阶段

#### 软件开发模型

 - ~ 是软件开发全部过程、活动和任务的结构框架。

 - 软件开发模型用于清晰、直观地表达软件开发的全过程，明确规定要完成的主要活动和任务，用来作为软件项目工作的基础。

 - 经典软件开发模型

  - 瀑布模型

  - 螺旋模型

  - 敏捷开发模型

  - ...

##### 瀑布模型（里程碑式的模型）

 - ~ 是 1970 年有温斯顿·罗伊斯（W·Royce）提出的软件开发模型，也是最早得到广泛应用的软件开发模型。

 - 目标模型核心要点

  - 将软件生命周期划分为多个阶段，并且规定了它们自上而下，相互衔接转换的固定顺序。

  - 软件开发过程主要依靠文档驱动，按照线性流程逐步进行。每个阶段的活动要有产出物。

  - 软件开发过程就是从第一个活动开始，严格按照各个活动的顺序逐级过渡来完成的。

##### 瀑布模型中的阶段

![title](./images/software-test-cycle/software-test-cycle-001.png)

##### 瀑布模型的特点

根据建筑领域中非常成熟的工程理念提出出来的构造理念。

 - 瀑布模型的优点

  - 明确划分了软件生命周期的各个环节。

  - 有清晰的工作流程，便于分工协作。

 - 瀑布模型的缺点

  - 线性的开发流程，带来巨大的风险。

  - 以一个建筑工程的例子来类比软件开发。
  
     - 地基测量、盖多少层楼。全是依靠图纸的设计来完成的。

     - 上层建筑在盖的过程当中，地基就无法再进行修改了。

     - 如果地基设计为 10 层楼高，再交付过程中用户提出要再加 5 层。
     
         - 最终结局可能是整栋楼要被爆破掉。

         - 因为前面的工作都是不能重复返工的。

         - 如果要进行返工成本和代价是非常高昂的。

 - 强调活动和阶段之间的衔接，开发周期缺乏弹性。

  - 高度依赖开发过程生命周期之间的串接。

  - 需求层面如果出现问题
  
     - 设计也就不可靠了

     - 编码可能就没有用了

     - 测试也就白做了

 - 厌恶需求变更和开发活动中的各种不确定性。

##### 螺旋模型

 - ~ 是 1988 年由巴里·勃姆 提出的一种演化的软件开发模型，它兼顾了快速原型模型和瀑布模型的优点。

快速原型模型（参考迭代模型）：

 - 软件的开发不要追求一次性成型、一步到位。而是要想滚雪球式的反复开展。

 - 不断的去达成我们的研发目标。

##### 螺旋模型的核心要点

 - 引入了其他模型不具备的 `风险分析` ，使软件再无法排除重大风险时有机会停止，以减小损失。

 - 要求在每个迭代阶段都构建原型以减小项目的开发风险。

 - 软件开发活动由风险驱动，在每次迭代时都要进行评估和风险分析。

![title](./images/software-test-cycle/software-test-cycle-002.png)

核心：

 - 工作不要求一步到位。

 - 采用循环逐级向研发目标逐级靠拢的方式。

 - 在每个阶段的工作当中，引入风险分析、进行大量的评审。

 - 在软件的每一个开发阶段要求产出原型
 
  - 软件需求 - 原型 1
  
  - 产品设计 - 原型 2

  - 详细设计 - 可运行原型

##### 螺旋模型的特点

 - 螺旋模型的优点

  - 通过风险分析，有效地降低软件失败造成的损失。

  - 在每个迭代阶段都引入软件测试，使每个阶段的质量得到保证。

  - 整体过程具备很高的灵活性，在开发过程的任何阶段自由应对变化。

 - 螺旋模型的缺点

  - 过于依赖风险分析经验与技术。

     - 需要非常有经验的技术人员参与。

     - 对于用户的思想、业务逻辑的理解可能与用户有出入。

  - 比较适合大型软件的开发。

     - 中小型软件开发风险与技术要求较低，繁复的工作会降低开发速度。

##### 敏捷开发模型

敏捷开发

敏捷思想和敏捷开发方法

 - ~ 是一种从 20 世纪 90 年代开始逐渐引起广泛关注的，可以应对需求快速变化的新型软件开发方法。

 - 敏捷思想催生了一系列敏捷开发方法，它们的具体名称、理念、过程、术语都不尽相同。但相对于传统方法，敏捷开发方法更强调：

  - 技术团队与业务专家之间的紧密协作和面对面沟通。

  - 频繁交付新的软件版本。

  - 紧凑而自我组织性的团队。

  - 能够很好地适应需求变化的代码编写和团队组织方法。

经典的敏捷开发方法

 - 极限编程

 - Scrum

 - 精益开发 ...

![title](./images/software-test-cycle/software-test-cycle-003.png)

 - 产品负责人（PO）

 - 敏捷开发主管（Scrum Manager）

 - 团队（Team）

迭代、增量开发模式

 - 开发人员专注于研发流程

 - 测试人员专注于测试流程

 - 自动化
 
  - 减少一些不必要的工作。

  - 代码的分发

  - 源代码管理

  - 开发过程中的中间版本的上线工作，交付工作

  - 迭代开发，在原有系统功能的基础上添加一些新的功能。

     - 对原有功能的自动化测试、回归测试

  - 通过一些脚本来完成

强调的是一种快速的响应、对于需求变更的一种可能够快速适应的能力。

#### 软件测试流程

![title](./images/software-test-cycle/software-test-cycle-004.png)

 - 1、测试计划阶段

  - 根据项目评估测试工作所需要的资源和风险，安排工作进度和测试周期，明确测试 `目标` 、`范围` 、`策略` 和 `相关技术` 等内容。

  - 周期、人员、资金、设备的使用固定下来。

  - 测试阶段对于计划的风险做一个全盘的考虑、测试计划的制定。

  - 在软件开发的立项阶段就可以开始工作了。伴随软件初期的规划阶段就已经开始在进行了。

 - 2、测试设计阶段

  - 测试方案。

  - 设计测试用例、环境和脚本。

     - 测试用例：测试软件所使用的操作步骤，数据的集合。

     - 测试环境：性能测试、安全性测试、兼容性测试依赖测试环境。

     - 测试脚本：设计、录制、编写一些测试脚本。

 - 3、测试实施阶段

  - 使用人工或自动手段执行测试。

     - 阶段测试的目标

     - 达成的目的

  - 报告发现的缺陷并跟踪缺陷的处理。

 - 4、测试评审阶段

  - 总结和审议测试的和结果。

    - 设计的测试用例执行的情况。

    - 有发现多少缺陷。

    - 开发人员是怎样响应的。

    - 在以后的测试阶段，如何规避与提升我们的代码质量。

    - 规划未来下一步的工作。

#### 软件测试的分类

 - 基于策略分类

  - 黑盒测试和白盒测试

  - 手动测试和自动测试

 - 基于阶段分类

  - 单元测试、集成测试、系统测试、验收测试

 - 基于特性非分类

  - 功能测试

  - 非功能测试

##### 基于策略分类

###### 黑盒测试和白盒测试

黑盒测试

 - ~ 也称功能测试或数据驱动测试。

  - 根据数据的输入和输出推断软件的功能是否是正常。
  
  - 准备多组数据的输入和输出，综合验证软件的功能，才能够推定程序验证的结果。

 - ~ 是对软件的界面和功能进行的测试。

 - ~ 需要需求规格说明书、用户手册等相关说明文档。

 - 软件运行的性能、稳定性、兼容性、软件界面是否容易操作、用户体验。

白盒测试

 - ~ 也称结构测试或逻辑驱动测试。

 - ~ 是对软件的源代码和架构进行的测试。

  - 依靠程序源代码、业务流程图、相关设计文档。

  - 对于软件的测试相对来讲就比较更加的准确、可靠。

 - ~ 需要源代码、流程图等相关设计文档。

 - 测试软件的代码、软件的根基。

###### 手动测试和自动测试

手动测试

 - ~ 是由人工驱动进行测试。

 - 测试的核心是人，需要发挥人的主观能动性，借助经验和判断来完成测试工作。

 - 用户体验、推断分析的一些场景。

自动测试

 - ~ 是由设备和工具驱动进行的测试。

 - 测试的核心仍然是人，有测试人员编制脚本驱动测试工具自动完成测试工作，仍然需要人的干预。

##### 基于阶段分类

 - 单元测试（开发环境 - 发现缺陷解决缺陷）

  - ~ 也称模块测试，是对软件的最小可测单元进行的测试活动。

  - 单元测试需要对模块的内部代码、内部结构、内部流程，做非常详细的测试。

  - 单元测试保证每一个模块、零件都是可靠的。

 - 集成测试（开发环境）

  - ~ 也称组装测试或联合测试，是在单元测试的基础上，
  
     将模块按照设计要求组装成系统或子系统，再进行测试活动。

  - 测试数据接口、数据结构、模块的输入输出（数据的加工与传递）。

  - 将零件进行组装，形成一个系统或是一个子系统。这个系统是否能够合理的高效的运行。

 - 系统测试（开发环境）

  - ~ 是将软件与计算机硬件、支持软件、数据和人员等要素结合在一起，
  
     针对整个产品进行的测试活动。
  
  - 测试的环境， 

  - 如要将软件再经过单元和集成测后，软件项目开发已经比较完整了。
  
     将软件安装部署到一个实际的机器上面，安装配套的操作系统、数据库、
     
     中间件、驱动程序等支持的软件，以及大量的数据。进行全方位的测试。

 - 验收测试（交付）

  - ~ 也称交付测试，是按照验收依据对整个系统进行的测试活动。

  - 向用户证明我的软件可以正常的工作。

  - 如用户在购买手机时，插上电话卡打个电话、发个短信、拍张照片
  
     这些就是做的验收测试，只是证明我买到的是一个可以使用的产品。

##### 软件测试的 W 模型

![title](./images/software-test-cycle/software-test-cycle-005.png)

##### 基于特性非分类

 - 功能测试

 - 效率测试

  - 特定性能测试

  - 负载测试

  - 压力测试

  - 疲劳强度测试

  - 资源利用测试

  - 性能可扩展性测试

 - 易用性测试

  - 功能易用性测试

  - 界面易用性测试

 - 安全性测试

 - 故障转移和恢复测试

 - 可移植性测试

  - 安装卸载测试

  - 兼容性测试

  - 可替代性测试

  - 可扩展性测试

 - 文档测试

 - 本地化测试

 - ...
	</textarea>
</div>

<div id="show"></div>
</body>
</html>