<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hibernate ORM</title>
</head>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/LanEditor.css"/>
<link rel="stylesheet" type="text/css" href="../plugin/LanEditor/highlight/styles/idea.css">

<link href="../plugin/SyntaxHighlighter/main.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shCore.css" rel='stylesheet' type='text/css'>
<link href="../plugin/SyntaxHighlighter/shThemeDefault.css" rel='stylesheet' type='text/css'>
<link href="../plugin/LanEditor/main.css" rel='stylesheet' type='text/css'>

<script src="../plugin/SyntaxHighlighter/shCore-convert.js" type='text/javascript'></script>
<script src="../plugin/SyntaxHighlighter/shBrushAll.js" type='text/javascript'></script>

<script type="text/javascript" src="../plugin/LanEditor/jquery-1.11.1.min.js"></script>
<script type="text/javascript" src="../plugin/LanEditor/LanEditor.js"></script>

<script type="text/javascript">
    $(document).ready(function () {
        //初始化 @textelem:编辑区的id @showelem可以省略
        var lan = LanEditor.init({
            textelem: "editor",
            showelem: "show"
        });
        //如果初始化失败，则显示出错信息
        if(lan.status == false){
            alter(lan.message);
            return ;
        }else{
            // 默认保存LanEditor快速指南文件
            // 获取文件创建的时间
            var createTime = LanEditor.Time.GetTimestamp();
            // 文件名
            LanEditor.File.CurOpenFile.name = $(document).attr("title");
            // 创建时间
            LanEditor.File.CurOpenFile.time = createTime;
            // 保存文件
            LanEditor.File.SaveFile();
            // 渲染
            LanEditor.RenderHTML();
        }
    });
</script>
<body>
<div id="edit">
    <textarea id="editor" name="editor">
理解 Hibernate 的关联映射

理解 ***```inverse```*** 属性、***```cascade```*** 属性

掌握单向的多对一、双向的一对多映射

掌握延迟加载

#### 关联关系的定义，理解

##### 关联关系

数据库：数据库里面表和表之间只有 一对多 或 多对多 的关系，没有 多对一 的这种关系；

```textarea
Hibernate： 一对多，多对多，一对一，多对一
            他们中又分为 单向的关联，双向的关联
```

特点：

 - 单向的关联：单向的话就只配置一边
 -  双向的关联：双向的话就两边都配置，多个一方配置多对一，一的地方配置配置一对多。
 
理解：

 - 数据库对关系表进行操作的注意事项（标准）
 
 - 这是最基础的准备工作：多对一映射在对数据进行更改时，会有一些限制。当没有该用户组时，添加用户，就会出错，当该用户组有用户时，删除该用户组也会报错。
我们当然可以按一般的方法来做。添加的时候，先手动添加组，再添加用户。删除时，先删除所有的用户，再删除用户组。
但是 Hibernate 为我们提供了一种便捷的方式——many-to-one。在映射文件 hbm.xml 中配置后，就可以不用再想那些限制了。Hibernate 会自动添加上所引用的数据。

 - 可以将 Hibernate 中的关联关系（单向，双向）理解成每项是一种 Hibernate 配置映射配置文件的配置方案；
 
以员工和部门这两张表为基础来讲解：

 - 多对一关联关系
 
从 员工 向  部门 来看，多个员工对应同一个部门，员工和部门是多对一

```textarea
          Emp                                         Dept 
    empNo   : Integer                          deptNo   : byte
    dept    : Dept             n --> 1         deptName : String
    empName : String                           location : String
```

 - 一对多双向关联关系

从 部门 向 员工 看，一个部门对应过个员工，部门和员工是一对多

```textarea
           Dept                                           Emp   
    deptNo   : byte                                empNo   : Integer
    deptName : String          1 <--> n            dept    : Dept
    location : String                              empName : String 
    empSet   : Set<Emp>
```

配置 多对一 单向关联的作用：

&#160; &#160;重点 使用 Emp set 方法 将 Dept 对象添加到 Emp 对象的 dept 字段中

 - 在保存 Emp 对象的时候他会自动，添加对 Dept 对象的引用；
 
 - 在不不指定 Emp 对象外键值的情况下，Hibernate 会根据传入的 dept 对象自动对外键赋值

配置从 Emp 到 Dept 的单向多对一单向关联

***```员工```***是***```多```*** ， ***```部门```***是***```一```*** ，配置的是单向关联，所以配置的是 员工

- 首先看实体类

***```Dept 持久化类```***

部门（一）：部门 的那一边没有变化

```java
public class Dept implements Serializable {

	// Fields

	private Integer deptNo;
	private String dname;
	private String loc;

	// Constructors

	/** default constructor */
	public Dept() {
	}
}
```

***```Emp 持久化类```***

员工（多）：员工 的一边，员工类中本来的 部门 id 现在变成了部门对象（实体）；

```java
public class Emp implements Serializable {

	// Fields

	// 员工编号
	private Integer empno;

	// 员工姓名
	private String ename;

	// 引用部门对象
	private Dept dept;

	// Constructors

	/** default constructor */
	public Emp() {
	}
}
```

- 再看实体映射配置文件

***```Dept.hbm.xml```***

部门实体：没有变化；

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- Mapping file autogenerated by MyEclipse Persistence Tools -->
<hibernate-mapping>
	<class name="com.accp.hibernate.entity.Dept" table="DEPT">
		<id name="deptNo" type="java.lang.Integer">
			<column name="DEPTNO" />
			<generator class="sequence">
				<param name="sequence">SEQ_DEPTNO</param>
			</generator>
		</id>
		<property name="dname" type="java.lang.String">
			<column name="DNAME" />
		</property>
		
		<property name="loc" type="java.lang.String">
			<column name="LOC" />
		</property>
	</class>
</hibernate-mapping>
```

***```Emp.hbm.xml```***

员工实体：

 - 原先配置的部门编号的外键去除了
 
 - 多了一个 多对一配置 ```<many-to-one>``` 的元素；

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- Mapping file autogenerated by MyEclipse Persistence Tools -->
<hibernate-mapping>
	<class name="com.accp.hibernate.entity.Emp" table="EMP" schema="Y2">
		<id name="empno" type="java.lang.Integer">
			<column name="EMPNO" />
			<generator class="sequence">
				<param name="sequence">SEQ_EMPNO</param>
			</generator>
		</id>

		<property name="ename" type="java.lang.String">
			<column name="ENAME" />
		</property>

		<many-to-one name="dept" class="com.accp.hibernate.entity.Dept"
			fetch="select">
			<column name="DEPTNO" />
		</many-to-one>
	</class>
</hibernate-mapping>
```

- ***```name```***: 指的是实体中的字段名 ；

- ***```column```***: 指的是在员工表里面外键字段 ；

- ***```cascade```***: 指定两个对象之间的操作联动关系，对一个对象执行了操作之后，对其指定的级联对象也需要执行相同的操作；

- ***```class```***: 指的是 dept 这个字段的类型 ；

配置完成。
![](./images/Hibernate-orm/test-001.png)
查询结果：
![](./images/Hibernate-orm/test-result-001.png)

```java
public void testSave3() {
	Session session = null;
	try {
		session = HibernateUtils.getSession();
		session.beginTransaction();
		Dept dept = new Dept();
		dept.setDeptNo("1");
		dept.setDeptName("市场部");

		Emp emp1 = new Emp();
		emp1.setEmpNo(1001);
		emp1.setEmpName("张三");
		emp1.setDept(dept);

		Emp emp2 = new Emp();
		emp2.setEmpNo(1002);
		emp2.setEmpName("李四");
		emp2.setDept(dept);

		//普通方法 ：必须先保存 dept，再保存 emp  
		//配置了 many-to-one 则不用再手动 save dept了。  
		//session.save(dept);  
		session.save(emp1);
		session.save(emp2);

		session.getTransaction().commit();
	} catch(Exception e) {
		e.printStackTrace();
		session.getTransaction().rollback();
	} finally {
		HibernateUtils.closeSession(session);
	}
}
```

配置从 Emp 到 Dept 的双向多对一关联

实现双向多对一关联：

 - 在 ```一``` 的一方 配置 ```一对多```

 - 在 ```多``` 的一方 配置 ```多对一```
 
首先看实体类

部门（一）：部门 的那一边没有变化

员工（多）：员工 的一边，员工类中本来的 部门 id 现在变成了部门对象（实体）；

***```Dept 持久化类```***

增加了一个 set 集合，它可以不用 new

```java
public class Dept implements Serializable {

	// Fields

	private Integer deptNo;
	private String dname;
	private String loc;
	private Set<Emp> emps = new HashSet<Emp>();

	// Constructors

	/** default constructor */
	public Dept() {
	}
}
```

***```Dept 的实体映射配置文件```***

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- Mapping file autogenerated by MyEclipse Persistence Tools -->
<hibernate-mapping>
	<class name="com.accp.hibernate.entity.Dept" table="DEPT">
		<id name="deptNo" type="java.lang.Integer">
			<column name="DEPTNO" />
			<generator class="sequence">
				<param name="sequence">SEQ_DEPTNO</param>
			</generator>
		</id>
		<property name="dname" type="java.lang.String">
			<column name="DNAME" />
		</property>

		<property name="loc" type="java.lang.String">
			<column name="LOC" />
		</property>

		<!-- cascade属性值有 none \ save-update \ delete \ all：包含 save-update 和 delete 
			默认是 none -->
		<set name="emps" cascade="all">
			<key column="DEPTNO"></key>
			<one-to-many class="com.accp.hibernate.entity.Emp" />
		</set>

	</class>
</hibernate-mapping>
```
***```cascade```*** 属性值有

 - ***```none```***: 默认是 none

 - ***```save-update```***:

 - ***```delete```***:

 - ***```all```***: 包含 save-update 和 delete


```xml
<set name="emps">
    <key column="DEPTNO"></key>
    <one-to-many class="cn.jbit.hibernate.entity.Emp"></one-to-many>
</set>
```

 - ***```name```***: Dept 中的字段值

 - ***```<key>```***: 关联关系的键值

  - ***```column```***: 指的 Dept 实体在 Emp 实体中的外键字段

 - ***```<one-to-many>```***: 配置一对多关联关系的元素

  - ***```class```***: 集合里面的类型(外键字段所在的实体的全称)

***```Emp 持久化类```***

与单向多对一关联时没有变化


```java
public class Emp implements Serializable {

	// Fields

	// 员工编号
	private Integer empno;

	// 员工姓名
	private String ename;

	// 引用部门对象
	private Integer deptNo;

	// Constructors

	/** default constructor */
	public Emp() {
	}
}
```

***```Emp.hbm.xml```***

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- Mapping file autogenerated by MyEclipse Persistence Tools -->
<hibernate-mapping>
    <class name="com.accp.hibernate.entity.Emp" table="EMP" schema="Y2">
        <id name="empno" type="java.lang.Integer">
            <column name="EMPNO" />
            <generator class="sequence">
                <param name="sequence">SEQ_EMPNO</param>
            </generator>
        </id>
        <property name="ename" type="java.lang.String">
            <column name="ENAME" />
        </property>
        <!-- <property name="deptNo" type="java.lang.Integer">
            <column name="DEPTNO"></column>
        </property> -->
        <many-to-one name="dept" class="com.accp.hibernate.entity.Dept"
            fetch="select">
            <column name="DEPTNO" />
        </many-to-one>
    </class>
</hibernate-mapping>
```

配置完成。

![](./images/Hibernate-orm/test-002.png)

执行结果：

![](./images/Hibernate-orm/test-result-002.png)

注意事项：

 1. 如果没有设置 ```cascade``` 属性的值，将无法实现级联保存 。
 
 2. 如果 ```inverse``` 属性设置为 ```true```，并且 员工没有主动和部门建立关联关系将无法实现对员工部门编号的维护，也就是说员工虽然被添加到数据库中了，但是员工部门编号为 ```NULL``` 。

![](./images/Hibernate-orm/test-db-002.png)
	</textarea>
</div>

<div id="show"></div>
</body>
</html>